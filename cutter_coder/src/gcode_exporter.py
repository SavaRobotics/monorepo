from typing import List, Optional, TextIO
from datetime import datetime
import logging

from .config import CuttingConfig
from .toolpath_generator import Toolpath

logger = logging.getLogger(__name__)

class GCodeExporter:
    """Export toolpaths to G-code format"""
    
    def __init__(self, config: CuttingConfig, dialect: str = "linuxcnc"):
        self.config = config
        self.dialect = dialect
        self.line_number = 10
        self.line_increment = 10
        
    def export(self, toolpaths: List[Toolpath], output_file: str) -> str:
        """Export toolpaths to G-code file"""
        with open(output_file, 'w') as f:
            self._write_header(f)
            self._write_setup(f)
            
            for i, toolpath in enumerate(toolpaths):
                self._write_toolpath(f, toolpath, i)
            
            self._write_footer(f)
        
        logger.info(f"G-code exported to {output_file}")
        return output_file
    
    def export_to_string(self, toolpaths: List[Toolpath]) -> str:
        """Export toolpaths to G-code string"""
        lines = []
        
        # Header
        lines.extend(self._get_header_lines())
        lines.extend(self._get_setup_lines())
        
        # Toolpaths
        for i, toolpath in enumerate(toolpaths):
            lines.extend(self._get_toolpath_lines(toolpath, i))
        
        # Footer
        lines.extend(self._get_footer_lines())
        
        return '\n'.join(lines)
    
    def _write_header(self, f: TextIO):
        """Write G-code header"""
        lines = self._get_header_lines()
        for line in lines:
            f.write(line + '\n')
    
    def _get_header_lines(self) -> List[str]:
        """Generate header lines"""
        lines = []
        lines.append(f"% Generated by DXF to G-Code Converter")
        lines.append(f"% Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append(f"% Material: {self.config.material.type}")
        lines.append(f"% Thickness: {self.config.material.thickness}mm")
        lines.append(f"% Tool Diameter: {self.config.tool.diameter}mm")
        lines.append(f"%")
        return lines
    
    def _write_setup(self, f: TextIO):
        """Write machine setup G-code"""
        lines = self._get_setup_lines()
        for line in lines:
            f.write(line + '\n')
    
    def _get_setup_lines(self) -> List[str]:
        """Generate setup lines"""
        lines = []
        
        # Program start
        lines.append(self._format_line("G90", "Absolute positioning"))
        lines.append(self._format_line("G21", "Metric units"))
        lines.append(self._format_line("G17", "XY plane selection"))
        lines.append(self._format_line("G40", "Cancel cutter compensation"))
        lines.append(self._format_line("G49", "Cancel tool length offset"))
        lines.append(self._format_line("G80", "Cancel canned cycle"))
        lines.append(self._format_line("G94", "Feed rate per minute"))
        
        # Spindle setup
        lines.append(self._format_line(
            f"S{self.config.material.spindle_speed} M3", 
            "Start spindle clockwise"
        ))
        
        # Pause for spindle spin-up
        lines.append(self._format_line("G4 P2", "Dwell 2 seconds"))
        
        # Move to safe height
        lines.append(self._format_line(
            f"G0 Z{self.config.safety_height}", 
            "Move to safety height"
        ))
        
        return lines
    
    def _write_toolpath(self, f: TextIO, toolpath: Toolpath, index: int):
        """Write a single toolpath"""
        lines = self._get_toolpath_lines(toolpath, index)
        for line in lines:
            f.write(line + '\n')
    
    def _get_toolpath_lines(self, toolpath: Toolpath, index: int) -> List[str]:
        """Generate toolpath lines"""
        lines = []
        
        # Toolpath comment
        lines.append(f"")
        lines.append(f"% Toolpath {index + 1}: {toolpath.type}")
        
        last_z = None
        last_feed = None
        rapid_height = self.config.safety_height
        
        for i, (x, y, z) in enumerate(toolpath.points):
            if i == 0:
                # First move - rapid to XY at safe height
                lines.append(self._format_line(
                    f"G0 X{x:.3f} Y{y:.3f}",
                    "Rapid to start position"
                ))
            else:
                # Determine move type
                if z > last_z and z >= rapid_height * 0.9:
                    # Rapid move (retract)
                    lines.append(self._format_line(f"G0 Z{z:.3f}"))
                    if x != toolpath.points[i-1][0] or y != toolpath.points[i-1][1]:
                        lines.append(self._format_line(f"G0 X{x:.3f} Y{y:.3f}"))
                elif z < last_z:
                    # Plunge move
                    if last_feed != toolpath.plunge_rate:
                        lines.append(self._format_line(
                            f"F{toolpath.plunge_rate:.0f}",
                            "Set plunge rate"
                        ))
                        last_feed = toolpath.plunge_rate
                    lines.append(self._format_line(f"G1 Z{z:.3f}"))
                else:
                    # Cutting move
                    if last_feed != toolpath.feed_rate:
                        lines.append(self._format_line(
                            f"F{toolpath.feed_rate:.0f}",
                            "Set feed rate"
                        ))
                        last_feed = toolpath.feed_rate
                    
                    # Determine if we need Z movement
                    if z != last_z:
                        lines.append(self._format_line(
                            f"G1 X{x:.3f} Y{y:.3f} Z{z:.3f}"
                        ))
                    else:
                        lines.append(self._format_line(
                            f"G1 X{x:.3f} Y{y:.3f}"
                        ))
            
            last_z = z
        
        # Retract at end of toolpath
        if last_z and last_z < rapid_height:
            lines.append(self._format_line(
                f"G0 Z{rapid_height:.3f}",
                "Retract to safety height"
            ))
        
        return lines
    
    def _write_footer(self, f: TextIO):
        """Write G-code footer"""
        lines = self._get_footer_lines()
        for line in lines:
            f.write(line + '\n')
    
    def _get_footer_lines(self) -> List[str]:
        """Generate footer lines"""
        lines = []
        
        lines.append("")
        lines.append("% Program end")
        
        # Return to home
        lines.append(self._format_line(
            f"G0 Z{self.config.safety_height + 10}",
            "Final retract"
        ))
        lines.append(self._format_line("M5", "Stop spindle"))
        lines.append(self._format_line("G0 X0 Y0", "Return to origin"))
        lines.append(self._format_line("M30", "Program end"))
        lines.append("%")
        
        return lines
    
    def _format_line(self, code: str, comment: Optional[str] = None) -> str:
        """Format a G-code line with optional line number and comment"""
        if self.dialect == "linuxcnc":
            # LinuxCNC doesn't require line numbers
            if comment:
                return f"{code} ({comment})"
            else:
                return code
        else:
            # Other dialects might use line numbers
            line = f"N{self.line_number} {code}"
            self.line_number += self.line_increment
            
            if comment:
                line += f" ({comment})"
            
            return line

class GCodeOptimizer:
    """Optimize G-code for better performance"""
    
    @staticmethod
    def optimize_rapids(gcode_lines: List[str]) -> List[str]:
        """Combine rapid moves when possible"""
        optimized = []
        i = 0
        
        while i < len(gcode_lines):
            line = gcode_lines[i]
            
            # Check for consecutive G0 moves
            if line.strip().startswith('G0') and i + 1 < len(gcode_lines):
                next_line = gcode_lines[i + 1]
                
                if next_line.strip().startswith('G0'):
                    # Combine moves
                    combined = GCodeOptimizer._combine_moves(line, next_line)
                    if combined:
                        optimized.append(combined)
                        i += 2
                        continue
            
            optimized.append(line)
            i += 1
        
        return optimized
    
    @staticmethod
    def _combine_moves(line1: str, line2: str) -> Optional[str]:
        """Combine two G0 moves if possible"""
        # Extract coordinates from both lines
        coords = {}
        
        for line in [line1, line2]:
            parts = line.split()
            for part in parts:
                if part.startswith('X'):
                    coords['X'] = part
                elif part.startswith('Y'):
                    coords['Y'] = part
                elif part.startswith('Z'):
                    coords['Z'] = part
        
        if coords:
            result = "G0"
            for axis in ['X', 'Y', 'Z']:
                if axis in coords:
                    result += f" {coords[axis]}"
            
            # Preserve comment from first line if any
            if '(' in line1:
                comment_start = line1.index('(')
                result += " " + line1[comment_start:]
            
            return result
        
        return None
    
    @staticmethod
    def remove_redundant_commands(gcode_lines: List[str]) -> List[str]:
        """Remove redundant modal commands"""
        optimized = []
        current_modes = {}
        
        for line in gcode_lines:
            if line.strip().startswith('%') or line.strip().startswith('('):
                # Keep comments and program markers
                optimized.append(line)
                continue
            
            # Check for modal commands
            parts = line.split()
            if parts:
                command = parts[0]
                
                # Modal groups
                if command in ['G90', 'G91']:  # Distance mode
                    if current_modes.get('distance') != command:
                        current_modes['distance'] = command
                        optimized.append(line)
                elif command in ['G20', 'G21']:  # Units
                    if current_modes.get('units') != command:
                        current_modes['units'] = command
                        optimized.append(line)
                elif command in ['G17', 'G18', 'G19']:  # Plane selection
                    if current_modes.get('plane') != command:
                        current_modes['plane'] = command
                        optimized.append(line)
                else:
                    # Keep all other lines
                    optimized.append(line)
        
        return optimized